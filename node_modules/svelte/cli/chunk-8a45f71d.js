'use strict';

var path = require('path');
var fs = require('fs');
var svelte = require('../compiler.js');

const { FORCE_COLOR, NODE_DISABLE_COLORS, TERM } = process.env;

const $ = {
	enabled: !NODE_DISABLE_COLORS && TERM !== 'dumb' && FORCE_COLOR !== '0'
};

const CODES = {
	// modifiers
	reset: code(0, 0),
	bold: code(1, 22),
	dim: code(2, 22),
	italic: code(3, 23),
	underline: code(4, 24),
	inverse: code(7, 27),
	hidden: code(8, 28),
	strikethrough: code(9, 29),

	// colors
	black: code(30, 39),
	red: code(31, 39),
	green: code(32, 39),
	yellow: code(33, 39),
	blue: code(34, 39),
	magenta: code(35, 39),
	cyan: code(36, 39),
	white: code(37, 39),
	gray: code(90, 39),

	// background colors
	bgBlack: code(40, 49),
	bgRed: code(41, 49),
	bgGreen: code(42, 49),
	bgYellow: code(43, 49),
	bgBlue: code(44, 49),
	bgMagenta: code(45, 49),
	bgCyan: code(46, 49),
	bgWhite: code(47, 49)
};

function code(open, close) {
	return {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
}

function run(arr, str) {
	let i=0, tmp={};
	for (; i < arr.length;) {
		tmp = Reflect.get(CODES, arr[i++]);
		str = tmp.open + str.replace(tmp.rgx, tmp.open) + tmp.close;
	}
	return str;
}

function chain(keys) {
	let ctx = { keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(key) {
	return function (txt) {
		let isChain = !!this.keys;
		if (isChain) this.keys.includes(key) || this.keys.push(key);
		if (txt !== void 0) return $.enabled ? run(isChain ? this.keys : [key], txt+'') : txt+'';
		return isChain ? this : chain([key]);
	};
}

for (let key in CODES) {
	Object.defineProperty($, key, {
		value: init(key),
		enumerable: true,
		writable: false
	});
}

var kleur = $;

function stderr(msg) {
    console.error(msg); // eslint-disable-line no-console
}
function error(err) {
    stderr(kleur.red(err.message || err));
    if (err.frame) {
        stderr(err.frame);
    }
    else if (err.stack) {
        stderr(kleur.gray(err.stack));
    }
    process.exit(1);
}

function mkdirp(dir) {
    const parent = path.dirname(dir);
    if (dir === parent)
        return;
    mkdirp(parent);
    if (!fs.existsSync(dir))
        fs.mkdirSync(dir);
}
function compile(input, opts) {
    if (opts._.length > 0) {
        error(`Can only compile a single file or directory`);
    }
    const output = opts.output;
    const stats = fs.statSync(input);
    const isDir = stats.isDirectory();
    if (isDir) {
        if (!output) {
            error(`You must specify an --output (-o) option when compiling a directory of files`);
        }
        if (opts.name || opts.amdId) {
            error(`Cannot specify --${opts.name ? 'name' : 'amdId'} when compiling a directory`);
        }
    }
    const globals = {};
    if (opts.globals) {
        opts.globals.split(',').forEach(pair => {
            const [key, value] = pair.split(':');
            globals[key] = value;
        });
    }
    const options = {
        name: opts.name,
        format: opts.format,
        sourceMap: opts.sourcemap,
        globals,
        amd: opts.amdId
            ? {
                id: opts.amdId,
            }
            : undefined,
        css: opts.css !== false,
        dev: opts.dev,
        immutable: opts.immutable,
        generate: opts.generate || 'dom',
        customElement: opts.customElement,
        sveltePath: opts.sveltePath
    };
    if (isDir) {
        mkdirp(output);
        compileDirectory(input, output, options);
    }
    else {
        compileFile(input, output, options);
    }
}
function compileDirectory(input, output, options) {
    fs.readdirSync(input).forEach(file => {
        const src = path.resolve(input, file);
        const dest = path.resolve(output, file);
        if (path.extname(file) === '.html') {
            compileFile(src, dest.substring(0, dest.lastIndexOf('.html')) + '.js', options);
        }
        else {
            const stats = fs.statSync(src);
            if (stats.isDirectory()) {
                compileDirectory(src, dest, options);
            }
        }
    });
}
let SOURCEMAPPING_URL = 'sourceMa';
SOURCEMAPPING_URL += 'ppingURL';
function compileFile(input, output, options) {
    console.error(`compiling ${path.relative(process.cwd(), input)}...`); // eslint-disable-line no-console
    options = Object.assign({}, options);
    if (!options.name)
        options.name = getName(input);
    options.filename = input;
    options.outputFilename = output;
    const { sourceMap } = options;
    const inline = sourceMap === 'inline';
    let source = fs.readFileSync(input, 'utf-8');
    if (source[0] === 0xfeff)
        source = source.slice(1);
    let compiled;
    try {
        compiled = svelte.compile(source, options);
    }
    catch (err) {
        error(err);
    }
    const { js } = compiled;
    if (sourceMap) {
        js.code += `\n//# ${SOURCEMAPPING_URL}=${inline || !output
            ? js.map.toUrl()
            : `${path.basename(output)}.map`}\n`;
    }
    if (output) {
        const outputDir = path.dirname(output);
        mkdirp(outputDir);
        fs.writeFileSync(output, js.code);
        console.error(`wrote ${path.relative(process.cwd(), output)}`); // eslint-disable-line no-console
        if (sourceMap && !inline) {
            fs.writeFileSync(`${output}.map`, js.map);
            console.error(`wrote ${path.relative(process.cwd(), `${output}.map`)}`); // eslint-disable-line no-console
        }
    }
    else {
        process.stdout.write(js.code);
    }
}
function getName(input) {
    return path.basename(input)
        .replace(path.extname(input), '')
        .replace(/[^a-zA-Z_$0-9]+/g, '_')
        .replace(/^_/, '')
        .replace(/_$/, '')
        .replace(/^(\d)/, '_$1');
}

exports.compile = compile;
