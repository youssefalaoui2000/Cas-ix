'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var fs = require('fs');
var svelte = require('../compiler/svelte.js');

const $ = { enabled:true };

const CODES = {
  // modifiers
  reset: fmt(0, 0),
  bold: fmt(1, 22),
  dim: fmt(2, 22),
  italic: fmt(3, 23),
  underline: fmt(4, 24),
  inverse: fmt(7, 27),
  hidden: fmt(8, 28),
  strikethrough: fmt(9, 29),
  // colors
  black: fmt(30, 39),
  red: fmt(31, 39),
  green: fmt(32, 39),
  yellow: fmt(33, 39),
  blue: fmt(34, 39),
  magenta: fmt(35, 39),
  cyan: fmt(36, 39),
  white: fmt(37, 39),
  gray: fmt(90, 39),
  // background colors
  bgBlack: fmt(40, 49),
  bgRed: fmt(41, 49),
  bgGreen: fmt(42, 49),
  bgYellow: fmt(43, 49),
  bgBlue: fmt(44, 49),
  bgMagenta: fmt(45, 49),
  bgCyan: fmt(46, 49),
  bgWhite: fmt(47, 49)
};

function fmt(x, y) {
	return {
		open: `\x1b[${x}m`,
		close: `\x1b[${y}m`,
		rgx: new RegExp(`\\x1b\\[${y}m`, 'g')
	}
}

function run(key, str) {
	let tmp = CODES[key];
	return tmp.open + str.replace(tmp.rgx, tmp.open) + tmp.close;
}

function exec(key, str) {
	str += '';
	if (!$.enabled) return str;
	let arr = this.keys;
	while (arr.length > 0) {
		str = run(arr.shift(), str);
	}
	this.keys.push(key);
	return str;
}

function attach(key) {
	let ctx = { keys:[key] };
	let fn = exec.bind(ctx, key);
	for (let k in CODES) {
		Reflect.defineProperty(fn, k, {
			get() {
				ctx.keys.push(k);
				return fn;
			}
		});
	}
	return fn;
}

for (let k in CODES) {
	$[k] = attach(k);
}

var kleur = $;

function stderr(msg) {
    console.error(msg); // eslint-disable-line no-console
}
function error(err) {
    stderr(kleur.red(err.message || err));
    if (err.frame) {
        stderr(err.frame);
    }
    else if (err.stack) {
        stderr(kleur.gray(err.stack));
    }
    process.exit(1);
}

function mkdirp(dir) {
    const parent = path.dirname(dir);
    if (dir === parent)
        return;
    mkdirp(parent);
    if (!fs.existsSync(dir))
        fs.mkdirSync(dir);
}
function compile(input, opts) {
    if (opts._.length > 0) {
        error(`Can only compile a single file or directory`);
    }
    const output = opts.output;
    const stats = fs.statSync(input);
    const isDir = stats.isDirectory();
    if (isDir) {
        if (!output) {
            error(`You must specify an --output (-o) option when compiling a directory of files`);
        }
        if (opts.name || opts.amdId) {
            error(`Cannot specify --${opts.name ? 'name' : 'amdId'} when compiling a directory`);
        }
    }
    const globals = {};
    if (opts.globals) {
        opts.globals.split(',').forEach(pair => {
            const [key, value] = pair.split(':');
            globals[key] = value;
        });
    }
    const options = {
        name: opts.name,
        format: opts.format,
        sourceMap: opts.sourcemap,
        globals,
        amd: opts.amdId
            ? {
                id: opts.amdId,
            }
            : undefined,
        css: opts.css !== false,
        dev: opts.dev,
        immutable: opts.immutable,
        generate: opts.generate || 'dom',
        customElement: opts.customElement,
        store: opts.store,
        shared: opts.shared
    };
    if (isDir) {
        mkdirp(output);
        compileDirectory(input, output, options);
    }
    else {
        compileFile(input, output, options);
    }
}
function compileDirectory(input, output, options) {
    fs.readdirSync(input).forEach(file => {
        const src = path.resolve(input, file);
        const dest = path.resolve(output, file);
        if (path.extname(file) === '.html') {
            compileFile(src, dest.substring(0, dest.lastIndexOf('.html')) + '.js', options);
        }
        else {
            const stats = fs.statSync(src);
            if (stats.isDirectory()) {
                compileDirectory(src, dest, options);
            }
        }
    });
}
let SOURCEMAPPING_URL = 'sourceMa';
SOURCEMAPPING_URL += 'ppingURL';
function compileFile(input, output, options) {
    console.error(`compiling ${path.relative(process.cwd(), input)}...`); // eslint-disable-line no-console
    options = Object.assign({}, options);
    if (!options.name)
        options.name = getName(input);
    options.filename = input;
    options.outputFilename = output;
    const { sourceMap } = options;
    const inline = sourceMap === 'inline';
    let source = fs.readFileSync(input, 'utf-8');
    if (source[0] === 0xfeff)
        source = source.slice(1);
    let compiled;
    try {
        compiled = svelte.compile(source, options);
    }
    catch (err) {
        error(err);
    }
    const { js } = compiled;
    if (sourceMap) {
        js.code += `\n//# ${SOURCEMAPPING_URL}=${inline || !output
            ? js.map.toUrl()
            : `${path.basename(output)}.map`}\n`;
    }
    if (output) {
        const outputDir = path.dirname(output);
        mkdirp(outputDir);
        fs.writeFileSync(output, js.code);
        console.error(`wrote ${path.relative(process.cwd(), output)}`); // eslint-disable-line no-console
        if (sourceMap && !inline) {
            fs.writeFileSync(`${output}.map`, js.map);
            console.error(`wrote ${path.relative(process.cwd(), `${output}.map`)}`); // eslint-disable-line no-console
        }
    }
    else {
        process.stdout.write(js.code);
    }
}
function getName(input) {
    return path.basename(input)
        .replace(path.extname(input), '')
        .replace(/[^a-zA-Z_$0-9]+/g, '_')
        .replace(/^_/, '')
        .replace(/_$/, '')
        .replace(/^(\d)/, '_$1');
}

exports.compile = compile;
